这里解释以下第二种内存分配方式的算法：
	小于128B的情况下才会使用第二种分配方法

	该算法先用来一个union结构共享数据和指针
	用来一个freelist数组分配小于128B的情况，总共为16个元素
	8，16，24，32，40，48，56，64，72，80，88，96，104，112，120，128
	通过函数 ROUND_UP 向上取证(8进制的方法)
	union结构体充当指向下一个内存区域的指针，又充当数据。

	内存池概念：这个内存池是通过代码手动分配的一个空间大小

	chunk_alloc(size_t size, int& nobjs)：
		size ：分配内存大小
		nobjs：分配内存块数量
				这是一个分配内存空间的一个方法。
				举例：申请32B 空间的内存 20 块内存块。

				一开始startfree 和 endfree 都是指针 默认为0
				开始分配内存：分配两倍的内存区域大小。这里做了两个判断，第一判断之前分配内存大小
				是否还有剩余空间(尽量防止内存碎片)，第二是错误检查 ，第一个条件不成立的话，就通过
				malloc(系统方法)申请堆内存。如果申请失败就去第一个算法去申请，最终报错。
				
				正常情况下 申请40块32B大小区块(申请两倍大小)已经用掉20块32B 如果有新的小于128B的
				内存申请 则判断剩余的内存池是否 完全足够 完全足够在此基础上分配到上一次分配内存区域的
				地址。
				
				如果只满足一块大小 照样分配一块内存大小的区域。 直到内存池不够内存再进行最开始的申请内存方法。

				return 返回startfree指针(指向内存池初始位置) 它也可以代表申请内存大小。比如32B。提供给refill方法。

	refill：	(size_t n)
		n ：内存块大小 
				nobj代码里是默认设置了20块内存块。
				refill的作用先是调用 chunk_alloc方法分配内存池大小。
				假设得到chunk的大小为申请的是32B，实际上endfree可能是32*20B，
				第一个内存块交给freelist数组进行维护。其实就是交给一个指向申请好内存池的一个指针。
				剩下的操作就是将剩余的19块内存 通过链表的方式连接起来。obj在数组的某一个位置。
				它又可以表示指向下19块内存区域的指针。


	allocate ： (size_t n)
		n： 申请内存大小
				先找到数据管理内存的位置 如 30B 向上取证(8进制) 就取 32B的位置
				也就是freelist的第4个位置。
				先通过refill函数 ，找到内存池有没有空间进行分配内存 
				分配成功的话，那么将第四个位置的指针指向下一个内存块。
				当前内存块的指针返回给调用者。
	deallocate：(void *p,size_t n)
		*p ：需要释放掉的指针
		n ：其实没什么用(程序中没用到)
				同样大于128B就通过系统函数free释放掉内存就好了。
				小于的话找到指向该内存区域的指针。比如说该内存96B
				在第11块由freelist维护。那么与allocate反过来。将指针向上移动96B
				的内存长度等同于将该内存区域释放掉，而这一部分的内存区域交给freelist维护，
				其实本质上并没有回收掉这块内存，只不过是通过人为的管理将这一块内存块，
				交给调用者，下次调用的时候就会覆盖掉这一块的内存(也等同于将内存回收了)。

	有强迫症的话直接delete freelist数组就行直接全部回收就不会有这些事了，
	但本质上这个空间配置器第二个算法也就没用了。
	该问题其实是解决小区块内存碎片的问题，如果不喜欢也可以只用第一个算法就行了。
	本质上创建一个freelist数组就是为了缓存而已。
